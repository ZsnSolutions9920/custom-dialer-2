const express = require('express');
const https = require('https');
const authenticate = require('../middleware/auth');
const db = require('../db');
const { getIO } = require('../io');

const router = express.Router();

// Log a new call
router.post('/', authenticate, async (req, res) => {
  try {
    const { callSid, phoneNumber, direction } = req.body;
    const result = await db.query(
      `INSERT INTO kc_call_logs (agent_id, call_sid, phone_number, direction)
       VALUES ($1, $2, $3, $4) RETURNING *`,
      [req.agent.id, callSid, phoneNumber, direction || 'outbound']
    );

    const callLog = result.rows[0];

    const io = getIO();
    if (io) {
      io.to(`agent:${req.agent.id}`).emit('call:logged', callLog);
    }

    res.json(callLog);
  } catch (err) {
    console.error('Create call log error:', err);
    res.status(500).json({ error: 'Failed to log call' });
  }
});

// Update call status/duration
router.patch('/:callSid', authenticate, async (req, res) => {
  try {
    const { status, duration } = req.body;
    const result = await db.query(
      `UPDATE kc_call_logs
       SET status = COALESCE($1, status),
           duration = COALESCE($2, duration),
           ended_at = CASE WHEN $1 IN ('completed','no-answer','busy','canceled','failed') THEN NOW() ELSE ended_at END
       WHERE call_sid = $3 AND agent_id = $4
       RETURNING *`,
      [status, duration, req.params.callSid, req.agent.id]
    );

    const callLog = result.rows[0];
    if (!callLog) {
      return res.status(404).json({ error: 'Call log not found' });
    }

    const io = getIO();
    if (io) {
      io.to(`agent:${req.agent.id}`).emit('call:updated', callLog);
    }

    res.json(callLog);
  } catch (err) {
    console.error('Update call log error:', err);
    res.status(500).json({ error: 'Failed to update call' });
  }
});

// Delete a call log entry
router.delete('/:callSid', authenticate, async (req, res) => {
  try {
    const result = await db.query(
      `DELETE FROM kc_call_logs WHERE call_sid = $1 AND agent_id = $2 RETURNING *`,
      [req.params.callSid, req.agent.id]
    );

    if (!result.rows[0]) {
      return res.status(404).json({ error: 'Call log not found' });
    }

    const io = getIO();
    if (io) {
      io.to(`agent:${req.agent.id}`).emit('call:updated', result.rows[0]);
    }

    res.json({ success: true });
  } catch (err) {
    console.error('Delete call log error:', err);
    res.status(500).json({ error: 'Failed to delete call' });
  }
});

// Get monthly billing totals for the logged-in agent
router.get('/billing', authenticate, async (req, res) => {
  try {
    const rate = parseFloat(process.env.RATE_PER_MINUTE) || 0;
    const result = await db.query(
      `SELECT
         COALESCE(SUM(duration), 0) AS total_seconds,
         ROUND(COALESCE(SUM(duration), 0) / 60.0, 2) AS total_minutes,
         ROUND(COALESCE(SUM(duration), 0) / 60.0 * $1, 2) AS total_cost
       FROM kc_call_logs
       WHERE agent_id = $2
         AND started_at >= date_trunc('month', NOW())
         AND status = 'completed'`,
      [rate, req.agent.id]
    );
    const data = result.rows[0] || { total_seconds: 0, total_minutes: 0, total_cost: 0 };
    data.rate_per_minute = rate;
    res.json(data);
  } catch (err) {
    console.error('Billing query error:', err);
    res.status(500).json({ error: 'Failed to fetch billing' });
  }
});

// Get inbound call history for the agent
router.get('/inbound-history', authenticate, async (req, res) => {
  try {
    const result = await db.query(
      `SELECT * FROM kc_call_logs
       WHERE agent_id = $1 AND direction = 'inbound'
       ORDER BY started_at DESC
       LIMIT 50`,
      [req.agent.id]
    );
    res.json(result.rows);
  } catch (err) {
    console.error('Fetch inbound history error:', err);
    res.status(500).json({ error: 'Failed to fetch inbound history' });
  }
});

// Download call recording as MP3 (proxied through server with Twilio auth)
router.get('/:callSid/recording', authenticate, async (req, res) => {
  try {
    const result = await db.query(
      'SELECT recording_url FROM kc_call_logs WHERE call_sid = $1 AND agent_id = $2',
      [req.params.callSid, req.agent.id]
    );

    if (!result.rows[0] || !result.rows[0].recording_url) {
      return res.status(404).json({ error: 'Recording not found' });
    }

    const recordingUrl = result.rows[0].recording_url + '.mp3';
    const authString = Buffer.from(
      `${process.env.TWILIO_ACCOUNT_SID}:${process.env.TWILIO_AUTH_TOKEN}`
    ).toString('base64');

    // Fetch from Twilio and stream to client
    https.get(recordingUrl, { headers: { Authorization: `Basic ${authString}` } }, (twilioRes) => {
      // Follow redirect if Twilio returns one
      if (twilioRes.statusCode >= 300 && twilioRes.statusCode < 400 && twilioRes.headers.location) {
        https.get(twilioRes.headers.location, (redirectRes) => {
          res.set({
            'Content-Type': 'audio/mpeg',
            'Content-Disposition': `attachment; filename="${req.params.callSid}.mp3"`,
          });
          redirectRes.pipe(res);
        }).on('error', (err) => {
          console.error('Recording redirect fetch error:', err);
          res.status(502).json({ error: 'Failed to fetch recording' });
        });
        return;
      }

      res.set({
        'Content-Type': 'audio/mpeg',
        'Content-Disposition': `attachment; filename="${req.params.callSid}.mp3"`,
      });
      twilioRes.pipe(res);
    }).on('error', (err) => {
      console.error('Recording fetch error:', err);
      res.status(502).json({ error: 'Failed to fetch recording' });
    });
  } catch (err) {
    console.error('Recording download error:', err);
    res.status(500).json({ error: 'Failed to download recording' });
  }
});

// Get call history for the agent
router.get('/history', authenticate, async (req, res) => {
  try {
    const result = await db.query(
      `SELECT * FROM kc_call_logs
       WHERE agent_id = $1
       ORDER BY started_at DESC
       LIMIT 50`,
      [req.agent.id]
    );
    res.json(result.rows);
  } catch (err) {
    console.error('Fetch history error:', err);
    res.status(500).json({ error: 'Failed to fetch history' });
  }
});

module.exports = router;
